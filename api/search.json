[{"id":"dc3ddb3c3e294cfbfa2182d222982083","title":"Java","content":"封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。\n对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。使用封装有四大好处：\n\n良好的封装能够减少耦合。\n\n类内部的结构可以自由修改。\n\n可以对成员进行更精确的控制。\n\n隐藏信息，实现细节。\n  封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。\n\n\n以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\npublic class Person &#123;\n\n    private String name;\n    private int gender;\n    private int age;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public String getGender() &#123;\n        return gender &#x3D;&#x3D; 0 ? &quot;man&quot; : &quot;woman&quot;;\n    &#125;\n\n    public void work() &#123;\n        if (18 &lt;&#x3D; age &amp;&amp; age &lt;&#x3D; 50) &#123;\n            System.out.println(name + &quot; is working very hard!&quot;);\n        &#125; else &#123;\n            System.out.println(name + &quot; can&#39;t work any more!&quot;);\n        &#125;\n    &#125;\n&#125;\n继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。继承所描述的是“IS-A”的关系，如果有两个对象 A 和 B ，若可以描述为“A是B”，则可以表示 A 继承 B ，其中B是被继承者称之为父类或者超类， A 是继承者称之为子类或者派生类。实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”。诚然，继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。\n同时在使用继承时需要记住三句话：\n\n子类拥有父类非 private 的属性和方法。\n子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n子类可以用自己的方式实现父类的方法。\n\n在下面这个示例中，我们定义了两个静态内部类：Animal和Dog。Animal类中有一个方法eat()，用于输出“动物吃食物”的字符串。Dog类继承了Animal类，并新增了一个方法bark()，用于输出“狗叫：汪汪汪”的字符串。\npublic class Main &#123;\n    public static class Animal &#123;\n        public void eat() &#123;\n            System.out.println(&quot;动物吃食物&quot;);\n        &#125;\n    &#125;\n\n    public static class Dog extends Animal &#123;\n        public void bark() &#123;\n            System.out.println(&quot;狗叫：汪汪汪&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Dog dog &#x3D; new Dog();\n        dog.eat(); &#x2F;&#x2F; 调用继承自父类Animal的方法\n        dog.bark(); &#x2F;&#x2F; 调用子类Dog的方法\n    &#125;\n&#125;\n构造器通过前面我们知道子类可以继承父类的属性和方法，除了那些 private 的外还有一样是子类继承不了的—构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用 super() 即可。构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是 java 的聪明之处：编译器会默认给子类调用父类的构造器。但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用 super() 来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。\n对于继承而言，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。\nsuper关键字调用父类构造方法在Java中，每个类都有一个构造方法，用于创建这个类的对象。构造方法的主要作用是初始化对象的属性，确保对象能够正常工作。在创建对象时，构造方法会被自动调用。\n在继承关系中，子类会自动继承父类的构造方法，但是构造方法不能被继承，只能被调用。因此，在子类中必须显式调用父类的构造方法，以确保父类的属性也能被正确地初始化。这时我们可以使用super关键字来调用父类的构造方法。\n使用super关键字调用父类构造方法的格式如下所示：super(参数列表);这里的参数列表指的是父类构造方法的参数列表，包括类型和参数名。父类构造方法会根据传入的参数初始化其属性。\n示例代码及其分析现在我们来看下面这个示例代码：\npublic class Main &#123;\n    public static class Parent &#123;\n        private final int age;\n\n        public Parent(int age) &#123;\n            this.age &#x3D; age;\n        &#125;\n\n        public int getAge() &#123;\n            return age;\n        &#125;\n    &#125;\n\n    public static class Child extends Parent &#123;\n        private final String name;\n\n        public Child(int age, String name) &#123;\n            super(age);\n            this.name &#x3D; name;\n        &#125;\n\n        public String getName() &#123;\n            return name;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Child child &#x3D; new Child(10, &quot;Tom&quot;);\n        System.out.println(&quot;child&#39;s age: &quot; + child.getAge()); &#x2F;&#x2F; 输出：child&#39;s age: 10\n        System.out.println(&quot;child&#39;s name: &quot; + child.getName()); &#x2F;&#x2F; 输出：child&#39;s name: Tom\n    &#125;\n&#125;\n\n在Parent类中定义了一个私有属性age，并提供了一个有参构造方法Parent(int age)用于初始化这个属性。在Child类中，我们继承了Parent类，并定义了一个私有属性name，以及一个有参构造方法Child(int age, String name)用于初始化age和name属性。在Child的构造方法中，我们调用了父类Parent的构造方法super(age)，将传入构造方法的age参数传递给父类，以初始化父类的属性。然后再初始化子类Child的属性name。\n在Main类的main方法中，我们创建了一个Child对象child，并分别调用了child的getAge方法和getName方法，输出了它的属性值。最终输出结果为：child’s age: 10和child’s name: Tom。\n通过这个例子，我们可以看到，通过使用super关键字，子类Child能够调用父类Parent的构造方法，来初始化父类的属性。这样，我们就能够实现在子类中初始化多重属性，同时也确保了父类中的属性也能被正确地初始化。\nprotected关键字private 访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到 protected。对于 protected 而言，它指明就类用户而言，他是 private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。\n示例代码及其分析&#x2F;&#x2F; Vehicle.java\nclass Vehicle &#123;\n    private int speed;\n\n    protected void run() &#123;\n        System.out.println(&quot;Vehicle is running at &quot; + getSpeed() + &quot; km&#x2F;h&quot;);\n    &#125;\n\n    protected void setSpeed(int speed)&#123;\n        this.speed &#x3D; speed;\n    &#125;\n\n    protected int getSpeed()&#123;\n        return speed;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Car.java\nclass Car extends Vehicle &#123;\n    public Car(int speed) &#123;\n        setSpeed(speed);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; Main.java\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Car car &#x3D; new Car(120);\n        car.run(); &#x2F;&#x2F; 输出：Vehicle is running at 120 km&#x2F;h\n    &#125;\n&#125;\n\n关于作用：\nprotected访问修饰符允许其子类访问其定义的成员（方法和变量），并且允许同一个包内的其他类访问这些成员；\nprivate访问修饰符用来限定某个成员只能在定义该成员的类内部被访问。\n\n在这个例子中，将run()方法和speed成员变量定义为protected和private访问修饰符，可以确保speed成员变量只有在Vehicle类及其子类（例如Car类）中被访问和修改，保证了程序的安全性。\n向上转型在上面的继承中我们谈到继承是 IS-A 的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为向上转型。\nAnimal animal &#x3D; new Cat();\n向上转型是指将一个子类对象赋值给一个父类引用变量的过程，可以将子类对象当做父类对象对待。这个过程可以自动完成，因为子类对象包含了父类对象的全部特性，所以它可以被当作父类对象使用。在向上转型中，虽然父类引用变量只能看到从父类继承而来的属性和方法，但是实际执行的方法却是子类的方法，并且还能够访问子类中扩展的属性和方法。以下是一个例子：\nclass Animal &#123;\n    public void move() &#123;\n        System.out.println(&quot;Animal is moving!&quot;);\n    &#125;\n&#125;\n\nclass Cat extends Animal &#123;\n    @Override\n    public void move() &#123;\n        System.out.println(&quot;Cat is moving!&quot;);\n    &#125;\n\n    public void jump() &#123;\n        System.out.println(&quot;Cat is jumping!&quot;);\n    &#125;\n&#125;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Animal animal &#x3D; new Cat();  &#x2F;&#x2F; 向上转型\n        animal.move();  &#x2F;&#x2F; 执行的是 Cat 类中的 move() 方法\n        &#x2F;&#x2F;animal.jump();  &#x2F;&#x2F; 编译错误，Animal 类型没有 jump() 方法\n\n        Cat cat &#x3D; new Cat();\n        cat.move();  &#x2F;&#x2F; 执行的是 Cat 类中的 move() 方法\n        cat.jump();  &#x2F;&#x2F; 执行 Cat 类中的 jump() 方法\n    &#125;\n&#125;\n在上面的例子中，Cat 类继承自 Animal 类，并覆盖了 Animal 类中的 move() 方法，同时还新增了 jump() 方法。在 main() 方法中，Animal 类型的引用变量 animal 指向了 Cat 类型的对象，这就是向上转型，此时调用 move() 方法实际执行的是 Cat 类中的 move() 方法，因为 Cat 类覆盖了父类的 move() 方法。但是如果尝试调用 jump() 方法，就会导致编译错误，因为 jump() 方法是子类新增的方法，而 Animal 类没有实现该方法。在这个例子中，我们展示了向上转型的用法，即将子类对象当做父类对象对待，以实现代码的灵活使用和复用。\n在向上转型的过程中，父类引用变量只能看到从父类继承而来的属性和方法，而子类中新增的方法和属性是无法被父类引用变量访问的。但是，如果子类覆盖了从父类继承而来的方法，并且在子类中重新实现了该方法，那么在父类引用变量调用该方法的时候，实际执行的是子类中重新实现的方法。这个过程中并没有修改父类的方法，而是在子类中重新实现了该方法，称为方法的覆盖。\n谨慎继承在这里我们需要明确，继承存在如下缺陷：\n\n父类变，子类就必须变。\n继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n继承是一种强耦合关系。\n\n所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》 中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。\n多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n多态分为编译时多态和运行时多态:\n\n编译时多态主要指方法的重载\n运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\n\n所以对于多态我们可以总结如下：   指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。\n对于面向对象而言，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\n多态的实现条件在刚刚开始就提到了继承在为多态的实现做了准备。子类 Child 继承父类 Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类 Father 对象，也可以处理子类 Child 对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。\nJava实现多态有三个必要条件：继承、重写、向上转型。\n\n继承：在多态中必须存在有继承关系的子类和父类。\n\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n  只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n  对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。\n\n\n下面的代码中，乐器类 (Instrument) 有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。\npublic class Instrument &#123;\n    public void play() &#123;\n        System.out.println(&quot;Instrument is playing...&quot;);\n    &#125;\n&#125;\n\npublic class Wind extends Instrument &#123;\n    public void play() &#123;\n        System.out.println(&quot;Wind is playing...&quot;);\n    &#125;\n&#125;\n\npublic class Percussion extends Instrument &#123;\n    public void play() &#123;\n        System.out.println(&quot;Percussion is playing...&quot;);\n    &#125;\n&#125;\n\npublic class Music &#123;\n    public static void main(String[] args) &#123;\n        List&lt;Instrument&gt; instruments &#x3D; new ArrayList&lt;&gt;();\n        instruments.add(new Wind());\n        instruments.add(new Percussion());\n        for(Instrument instrument : instruments) &#123;\n            instrument.play();\n        &#125;\n    &#125;\n&#125;\n参考资料面向对象编程三大特性——封装、继承、多态Java 基础 - 面向对象\n","slug":"Java","date":"2023-04-25T00:00:00.000Z","categories_index":"Java","tags_index":"Java","author_index":"Joey"},{"id":"7f00768b865696d227f7b794a43f7717","title":"离散化","content":"什么是离散化离散化是把无限空间中有限的个体影射到有限的空间去，依此提高算法的效率。\n\n离散化是指将连续的数据转化为离散的数据，通常是将连续的数值分成若干个区间，然后用离散值来代表原始数据。离散化常用于处理数值型数据，特别是连续的数值型数据，因为这类数据通常难以处理，需要将其离散化之后才能使用一些算法。\n离散化本质上可以看成是一种 哈希，其保证数据在哈希以后仍然保持原来的全&#x2F;偏序关系。通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。用来离散化的可以是大整数、浮点数、字符串等等。\n区间和假定有一个无限长的数轴，数轴上每个坐标上的数都是 0现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和\n输入格式第一行包含两个整数 n 和 m。接下来 n 行，每行包含两个整数 x 和 c。再接下来 m 行，每行包含两个整数 l 和 r。\n输出格式共 m 行，每行输出一个询问中所求的区间内数字和。\n数据范围\n输入样例：3 3\n1 2\n3 6\n7 5\n1 3\n4 6\n7 8\n输出样例：8\n0\n5\n解析\n从图中可以看出，我们要算出各区间中的和，这个数据比较小可以直接for循环完成求和但如果数据很大呢？\n举个例子如果数据是只有和这两个位置有值，其他位置都为，要求的和，这时单是循环时间复杂度就会达到惊人的，这时使用离散化算法就只会用到和这两个位置的值，再用前缀和求值，复杂度就会降到，所以离散化的目的是就为了降低算法的时间复杂度\nSource Code#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n#define FastIOS ios::sync_with_stdio(false), cout.tie(0), cin.tie(0)\n#define int long long\nint n, m, i, j, k, t &#x3D; 0;\nconst int N &#x3D; 1e6 + 10;\ntypedef pair&lt;int, int&gt; PII;\nint a[N]; &#x2F;&#x2F;存储坐标插入的值\nint sum[N]; &#x2F;&#x2F;存储数组a的前缀和\nvector&lt;int&gt; alls; &#x2F;&#x2F;存储（所有与插入和查询有关的）坐标\nvector&lt;PII&gt; add, query; &#x2F;&#x2F;存储插入和询问操作的数据\n\nint find(int x)&#123;\t&#x2F;&#x2F;返回的是输入的坐标的离散化下标\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while(l &lt; r)&#123;\n        int mid &#x3D; l + (r - l &gt;&gt; 1);\n        if(alls[mid] &gt;&#x3D; x)\n            r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1;\n&#125;\n\nvoid solve()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(i &#x3D; 0; i &lt; n; i++)&#123;\n        int x, c;\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123;x, c&#125;);\n        alls.push_back(x);\n    &#125;  \n\n    for(i &#x3D; 0; i &lt; m; i ++)&#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123;l, r&#125;);\n        alls.push_back(l);\n        alls.push_back(r);\n    &#125;\n  \n    sort(alls.begin(), alls.end());\n    &#x2F;&#x2F;去重，返回一个迭代器，指向数组去重后不重复的序列的最后一个元素的下一个元素\n    alls.erase(unique(alls.begin(), alls.end()), alls.end());\n  \n    for(auto item : add)&#123;\n        int x &#x3D; find(item.first);\n        a[x] +&#x3D; item.second;\n    &#125;\n  \n    for(i &#x3D; 1; i &lt;&#x3D; alls.size(); i++)\n        sum[i] &#x3D; sum[i - 1] + a[i];\n  \n    for(auto item : query)&#123;\n        int l &#x3D; find(item.first), r &#x3D; find(item.second);\n        cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n\nsigned main()\n&#123;\n    FastIOS;\n    solve();\n    return 0;\n&#125;\n&#x2F;&#x2F; Thank U\n\n\n\n","slug":"离散化","date":"2023-04-25T00:00:00.000Z","categories_index":"C++","tags_index":"Algorithms","author_index":"Joey"}]