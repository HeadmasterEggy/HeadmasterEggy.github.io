[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\n什么是离散化离散化是把无限空间中有限的个体影射到有限的空间去，依此提高算法的效率。\n\n离散化是指将连续的数据转化为离散的数据，通常是将连续的数值分成若干个区间，然后用离散值来代表原始数据。离散化常用于处理数值型数据，特别是连续的数值型数据，因为这类数据通常难以处理，需要将其离散化之后才能使用一些算法。\n离散化本质上可以看成是一种 哈希，其保证数据在哈希以后仍然保持原来的全&#x2F;偏序关系。通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。用来离散化的可以是大整数、浮点数、字符串等等。\n区间和假定有一个无限长的数轴，数轴上每个坐标上的数都是 0现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和\n输入格式第一行包含两个整数 n 和 m。接下来 n 行，每行包含两个整数 x 和 c。再接下来 m 行，每行包含两个整数 l 和 r。\n输出格式共 m 行，每行输出一个询问中所求的区间内数字和。\n数据范围$−109≤x≤109,$$1≤n,m≤105,$$−109≤l≤r≤109,$$−10000≤c≤10000$\n输入样例：3 3\n1 2\n3 6\n7 5\n1 3\n4 6\n7 8\n\n输出样例：8\n0\n5\n\n解析\n从图中可以看出，我们要算出各区间中的和，这个数据比较小可以直接for循环完成求和但如果数据很大呢？\n举个例子如果数据是只有$1$和$10^9$这两个位置有值，其他位置都为$0$，要求$[1, 10^{9}]$的和，这时单是$for$循环时间复杂度就会达到惊人的$O(10^{9})$，这时使用离散化算法就只会用到$1$和$10^{9}$这两个位置的值，再用前缀和求值，复杂度就会降到$O(1)$，所以离散化的目的是就为了降低算法的时间复杂度\nSource Code#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n#define FastIOS ios::sync_with_stdio(false), cout.tie(0), cin.tie(0)\n#define int long long\nint n, m, i, j, k, t &#x3D; 0;\nconst int N &#x3D; 1e6 + 10;\ntypedef pair&lt;int, int&gt; PII;\nint a[N]; &#x2F;&#x2F;存储坐标插入的值\nint sum[N]; &#x2F;&#x2F;存储数组a的前缀和\nvector&lt;int&gt; alls; &#x2F;&#x2F;存储（所有与插入和查询有关的）坐标\nvector&lt;PII&gt; add, query; &#x2F;&#x2F;存储插入和询问操作的数据\n\nint find(int x)&#123;\t&#x2F;&#x2F;返回的是输入的坐标的离散化下标\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while(l &lt; r)&#123;\n        int mid &#x3D; l + (r - l &gt;&gt; 1);\n        if(alls[mid] &gt;&#x3D; x)\n            r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1;\n&#125;\n\nvoid solve()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(i &#x3D; 0; i &lt; n; i++)&#123;\n        int x, c;\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123;x, c&#125;);\n        alls.push_back(x);\n    &#125;  \n\n    for(i &#x3D; 0; i &lt; m; i ++)&#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123;l, r&#125;);\n        alls.push_back(l);\n        alls.push_back(r);\n    &#125;\n  \n    sort(alls.begin(), alls.end());\n    &#x2F;&#x2F;去重，返回一个迭代器，指向数组去重后不重复的序列的最后一个元素的下一个元素\n    alls.erase(unique(alls.begin(), alls.end()), alls.end());\n  \n    for(auto item : add)&#123;\n        int x &#x3D; find(item.first);\n        a[x] +&#x3D; item.second;\n    &#125;\n  \n    for(i &#x3D; 1; i &lt;&#x3D; alls.size(); i++)\n        sum[i] &#x3D; sum[i - 1] + a[i];\n  \n    for(auto item : query)&#123;\n        int l &#x3D; find(item.first), r &#x3D; find(item.second);\n        cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n\nsigned main()\n&#123;\n    FastIOS;\n    solve();\n    return 0;\n&#125;\n&#x2F;&#x2F; Thank U\n\n\n\n","slug":"离散化","date":"2023-04-25T07:52:50.344Z","categories_index":"","tags_index":"","author_index":"QiaoYi"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-04-23T07:11:08.852Z","categories_index":"","tags_index":"","author_index":"QiaoYi"}]