{"title":"离散化","uid":"7f00768b865696d227f7b794a43f7717","slug":"离散化","date":"2023-04-25T07:57:19.087Z","updated":"2023-04-25T07:58:43.564Z","comments":true,"path":"api/articles/离散化.json","keywords":null,"cover":[],"content":"<h1 id=\"什么是离散化\"><a href=\"#什么是离散化\" class=\"headerlink\" title=\"什么是离散化\"></a>什么是离散化</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">离散化是把无限空间中有限的个体影射到有限的空间去，依此提高算法的效率。</code></pre>\n\n<p>离散化是指将连续的数据转化为离散的数据，通常是将连续的数值分成若干个区间，然后用离散值来代表原始数据。离散化常用于处理数值型数据，特别是连续的数值型数据，因为这类数据通常难以处理，需要将其离散化之后才能使用一些算法。</p>\n<p>离散化本质上可以看成是一种 哈希，其保证数据在哈希以后仍然保持原来的全&#x2F;偏序关系。<br>通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。<br>用来离散化的可以是大整数、浮点数、字符串等等。</p>\n<h1 id=\"区间和\"><a href=\"#区间和\" class=\"headerlink\" title=\"区间和\"></a>区间和</h1><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0<br>现在，我们首先进行 <code>n</code> 次操作，每次操作将某一位置 <code>x</code> 上的数加 <code>c</code><br>接下来，进行 <code>m</code> 次询问，每个询问包含两个整数 <code>l</code> 和 <code>r</code>，你需要求出在区间 <code>[l,r]</code> 之间的所有数的和</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>第一行包含两个整数 <code>n</code> 和 <code>m</code>。<br>接下来 <code>n</code> 行，每行包含两个整数 <code>x</code> 和 <code>c</code>。<br>再接下来 <code>m</code> 行，每行包含两个整数 <code>l</code> 和 <code>r</code>。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>共 <code>m</code> 行，每行输出一个询问中所求的区间内数字和。</p>\n<h2 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h2><p><img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?%E2%88%92109%E2%89%A4x%E2%89%A4109,#card=math&code=%E2%88%92109%E2%89%A4x%E2%89%A4109%2C&id=ZeSPX\"><br><img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?1%E2%89%A4n,m%E2%89%A4105,#card=math&code=1%E2%89%A4n%2Cm%E2%89%A4105%2C&id=ISFwQ\"><br><img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?%E2%88%92109%E2%89%A4l%E2%89%A4r%E2%89%A4109,#card=math&code=%E2%88%92109%E2%89%A4l%E2%89%A4r%E2%89%A4109%2C&id=Qs7RI\"><br><img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?%E2%88%9210000%E2%89%A4c%E2%89%A410000#card=math&code=%E2%88%9210000%E2%89%A4c%E2%89%A410000&id=Si3fn\"></p>\n<h2 id=\"输入样例：\"><a href=\"#输入样例：\" class=\"headerlink\" title=\"输入样例：\"></a>输入样例：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">3 3\n1 2\n3 6\n7 5\n1 3\n4 6\n7 8</code></pre>\n<h2 id=\"输出样例：\"><a href=\"#输出样例：\" class=\"headerlink\" title=\"输出样例：\"></a>输出样例：</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">8\n0\n5</code></pre>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><p><img src=\"https://images-a2q.pages.dev/file/91ad727e7c9cbbf500d20.jpg#id=HeY1u&originHeight=1176&originWidth=1262&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\"></p>\n<p>从图中可以看出，我们要算出各区间中的和，这个数据比较小可以直接for循环完成求和<br>但如果数据很大呢？</p>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>如果数据是只有<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?1#card=math&code=1&id=E2iUO\">和<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?10%5E9#card=math&code=10%5E9&id=dcqfu\">这两个位置有值，其他位置都为<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?0#card=math&code=0&id=gMDne\">，要求<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?%5B1,%2010%5E%7B9%7D%5D#card=math&code=%5B1%2C%2010%5E%7B9%7D%5D&id=nN4qA\">的和，这时单是<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?for#card=math&code=for&id=Dmo5v\">循环时间复杂度就会达到惊人的<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?O(10%5E%7B9%7D)#card=math&code=O%2810%5E%7B9%7D%29&id=hFQIn\">，这时使用离散化算法就只会用到<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?1#card=math&code=1&id=iGE9s\">和<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?10%5E%7B9%7D#card=math&code=10%5E%7B9%7D&id=EYXy7\">这两个位置的值，再用前缀和求值，复杂度就会降到<img src=\"https://www.yuque.com/api/services/graph/generate_redirect/latex?O(1)#card=math&code=O%281%29&id=RJapa\">，所以离散化的目的是就为了降低算法的时间复杂度</p>\n<h2 id=\"Source-Code\"><a href=\"#Source-Code\" class=\"headerlink\" title=\"Source Code\"></a>Source Code</h2><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;bits&#x2F;stdc++.h&gt;\nusing namespace std;\n#define FastIOS ios::sync_with_stdio(false), cout.tie(0), cin.tie(0)\n#define int long long\nint n, m, i, j, k, t &#x3D; 0;\nconst int N &#x3D; 1e6 + 10;\ntypedef pair&lt;int, int&gt; PII;\nint a[N]; &#x2F;&#x2F;存储坐标插入的值\nint sum[N]; &#x2F;&#x2F;存储数组a的前缀和\nvector&lt;int&gt; alls; &#x2F;&#x2F;存储（所有与插入和查询有关的）坐标\nvector&lt;PII&gt; add, query; &#x2F;&#x2F;存储插入和询问操作的数据\n\nint find(int x)&#123;\t&#x2F;&#x2F;返回的是输入的坐标的离散化下标\n    int l &#x3D; 0, r &#x3D; alls.size() - 1;\n    while(l &lt; r)&#123;\n        int mid &#x3D; l + (r - l &gt;&gt; 1);\n        if(alls[mid] &gt;&#x3D; x)\n            r &#x3D; mid;\n        else l &#x3D; mid + 1;\n    &#125;\n    return r + 1;\n&#125;\n\nvoid solve()\n&#123;\n    cin &gt;&gt; n &gt;&gt; m;\n    for(i &#x3D; 0; i &lt; n; i++)&#123;\n        int x, c;\n        cin &gt;&gt; x &gt;&gt; c;\n        add.push_back(&#123;x, c&#125;);\n        alls.push_back(x);\n    &#125;  \n\n    for(i &#x3D; 0; i &lt; m; i ++)&#123;\n        int l, r;\n        cin &gt;&gt; l &gt;&gt; r;\n        query.push_back(&#123;l, r&#125;);\n        alls.push_back(l);\n        alls.push_back(r);\n    &#125;\n  \n    sort(alls.begin(), alls.end());\n    &#x2F;&#x2F;去重，返回一个迭代器，指向数组去重后不重复的序列的最后一个元素的下一个元素\n    alls.erase(unique(alls.begin(), alls.end()), alls.end());\n  \n    for(auto item : add)&#123;\n        int x &#x3D; find(item.first);\n        a[x] +&#x3D; item.second;\n    &#125;\n  \n    for(i &#x3D; 1; i &lt;&#x3D; alls.size(); i++)\n        sum[i] &#x3D; sum[i - 1] + a[i];\n  \n    for(auto item : query)&#123;\n        int l &#x3D; find(item.first), r &#x3D; find(item.second);\n        cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; &#39;\\n&#39;;\n    &#125;\n&#125;\n\nsigned main()\n&#123;\n    FastIOS;\n    solve();\n    return 0;\n&#125;\n&#x2F;&#x2F; Thank U</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/28161567/1681722532476-17e103c1-c9d8-42d2-a87e-72f53abb03ea.png#averageHue=%23f5f5f5&clientId=ucc208aef-bc84-4&from=paste&height=832&id=u0c84458a&name=image.png&originHeight=832&originWidth=1634&originalType=binary&ratio=2&rotation=0&showTitle=false&size=110095&status=done&style=none&taskId=u7e7aa3b6-3c50-4ab1-bc1b-1de47849cdb&title=&width=1634\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2023/png/28161567/1681722544870-1c083d76-d806-47df-8250-f1f49f349747.png#averageHue=%23f2f2f2&clientId=ucc208aef-bc84-4&from=paste&height=850&id=u3ef580cd&name=image.png&originHeight=850&originWidth=1558&originalType=binary&ratio=2&rotation=0&showTitle=false&size=151111&status=done&style=none&taskId=uc3d1922f-c372-4b17-8ee6-ad469286f01&title=&width=1558\" alt=\"image.png\"></p>\n<blockquote>\n</blockquote>\n","feature":true,"text":"什么是离散化离散化是把无限空间中有限的个体影射到有限的空间去，依此提高算法的效率。 离散化是指将连续的数据转化为离散的数据，通常是将连续的数值分成若干个区间，然后用离散值来代表原始数据。离散化常用于处理数值型数据，特别是连续的数值型数据，因为这类数据通常难以处理，需要将其离散化之...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E6%95%A3%E5%8C%96\"><span class=\"toc-text\">什么是离散化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4%E5%92%8C\"><span class=\"toc-text\">区间和</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4\"><span class=\"toc-text\">数据范围</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">输入样例：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">输出样例：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">举个例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Source-Code\"><span class=\"toc-text\">Source Code</span></a></li></ol></li></ol>","author":{"name":"QiaoYi","slug":"blog-author","avatar":"https://images-a2q.pages.dev/file/84e5f6a2578cc065d34e8.png","link":"/","description":"","socials":{"github":"https://github.com/HeadmasterEggy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://space.bilibili.com/161327271"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com161327271/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/161327271"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java","uid":"dc3ddb3c3e294cfbfa2182d222982083","slug":"Java","date":"2023-04-25T07:56:50.424Z","updated":"2023-04-25T08:08:39.891Z","comments":true,"path":"api/articles/Java.json","keywords":null,"cover":null,"text":"封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"QiaoYi","slug":"blog-author","avatar":"https://images-a2q.pages.dev/file/84e5f6a2578cc065d34e8.png","link":"/","description":"","socials":{"github":"https://github.com/HeadmasterEggy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://space.bilibili.com/161327271"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com161327271/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/161327271"}}}},"feature":true}}